<!doctype html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2026 蛇年大吉 - 终极3D烟花盛典</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background-color: #000; /* 纯黑背景，为了让光栅底座更亮 */
            font-family: "Microsoft YaHei", sans-serif;
        }

        /* 统一管理 Canvas，层层叠加 */
        .canvas-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* 层级 1: 3D 地面 & 原始 3D 烟花 (Base) */
        #canvas-3d-base { z-index: 1; }

        /* 层级 2: 高级物理烟花 (Fireworks) */
        #canvas-fireworks { z-index: 2; mix-blend-mode: screen; }

        /* 层级 3: 粒子文字 (Text) */
        #canvas-text { z-index: 3; pointer-events: none; }
    </style>
</head>
<body>

    <!-- 画布层 -->
    <canvas id="canvas-3d-base" class="canvas-layer"></canvas>
    <canvas id="canvas-fireworks" class="canvas-layer"></canvas>
    <canvas id="canvas-text" class="canvas-layer"></canvas>

<script>
/**
 * ============================================================================
 * 模块一：3D 光栅化地面引擎 (The "Base" Effect)
 * 还原第一版代码中的旋转地板效果
 * ============================================================================
 */
(function() {
    var canvas = document.getElementById("canvas-3d-base");
    var ctx = canvas.getContext("2d");
    var cx, cy, playerZ, playerX, playerY, pitch, yaw, scale, frames;
    
    // 初始化变量
    function initVars() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        cx = canvas.width / 2;
        cy = canvas.height / 2;
        playerZ = -25;
        playerX = playerY = pitch = yaw = 0;
        scale = 600;
        frames = 0;
    }

    // 核心光栅化算法
    function rasterizePoint(x, y, z) {
        var p, d;
        x -= playerX; y -= playerY; z -= playerZ;
        p = Math.atan2(x, z); d = Math.sqrt(x * x + z * z);
        x = Math.sin(p - yaw) * d; z = Math.cos(p - yaw) * d;
        p = Math.atan2(y, z); d = Math.sqrt(y * y + z * z);
        y = Math.sin(p - pitch) * d; z = Math.cos(p - pitch) * d;
        
        var rx1 = -1000, ry1 = 1, rx2 = 1000, ry2 = 1, rx3 = 0, ry3 = 0, rx4 = x, ry4 = z;
        var uc = (ry4 - ry3) * (rx2 - rx1) - (rx4 - rx3) * (ry2 - ry1);
        if (!uc) return { x: 0, y: 0, d: -1 };
        var ua = ((rx4 - rx3) * (ry1 - ry3) - (ry4 - ry3) * (rx1 - rx3)) / uc;
        var ub = ((rx2 - rx1) * (ry1 - ry3) - (ry2 - ry1) * (rx1 - rx3)) / uc;
        
        if (!z) z = 0.000000001;
        if (ua > 0 && ua < 1 && ub > 0 && ub < 1) {
            return {
                x: cx + (rx1 + ua * (rx2 - rx1)) * scale,
                y: cy + y / z * scale,
                d: Math.sqrt(x * x + y * y + z * z)
            };
        } else {
            return { d: -1 };
        }
    }

    // 绘制逻辑
    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // 绘制星空背景色
        ctx.fillStyle = "#ff8"; 

        // 绘制 3D 网格地板
        for (var i = -100; i < 100; i += 3) {
            for (var j = -100; j < 100; j += 4) {
                var x = i; var z = j; var y = 25; // y=25 是地面高度
                var point = rasterizePoint(x, y, z);
                if (point.d != -1) {
                    var size = 250 / (1 + point.d);
                    var d = Math.sqrt(x * x + z * z);
                    var a = 0.75 - Math.pow(d / 100, 6) * 0.75; // 距离衰减
                    if (a > 0) {
                        ctx.globalAlpha = a;
                        // 绘制光点
                        ctx.fillRect(point.x - size / 2, point.y - size / 2, size, size);
                    }
                }
            }
        }
        ctx.globalAlpha = 1;
    }

    // 每一帧的逻辑
    function frame() {
        frames++;
        // 摄像机旋转逻辑
        var p = Math.atan2(playerX, playerZ);
        var d = Math.sqrt(playerX * playerX + playerZ * playerZ);
        d += Math.sin(frames / 80) / 1.25;
        var t = Math.sin(frames / 200) / 40;
        playerX = Math.sin(p + t) * d;
        playerZ = Math.cos(p + t) * d;
        yaw = Math.PI + p + t;

        draw();
        requestAnimationFrame(frame);
    }

    window.addEventListener("resize", initVars);
    initVars();
    frame();
})();

/**
 * ============================================================================
 * 模块二：高级物理烟花引擎 (Fireworks Engine)
 * 负责空中的爆炸效果
 * ============================================================================
 */
(function() {
    const canvas = document.getElementById("canvas-fireworks");
    const ctx = canvas.getContext("2d");
    let width, height;
    
    // 物理变量
    let particles = [];
    let rockets = [];
    const gravity = 0.04;

    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
    }
    window.addEventListener('resize', resize);
    resize();

    class Particle {
        constructor(x, y, color) {
            this.x = x; this.y = y; this.color = color;
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * 3 + 1;
            this.vx = Math.cos(angle) * speed;
            this.vy = Math.sin(angle) * speed;
            this.alpha = 1;
            this.decay = Math.random() * 0.01 + 0.005;
        }
        update() {
            this.vx *= 0.95; this.vy *= 0.95; // 空气阻力
            this.vy += gravity;
            this.x += this.vx; this.y += this.vy;
            this.alpha -= this.decay;
        }
        draw(ctx) {
            ctx.save();
            ctx.globalAlpha = this.alpha;
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, 2, 0, Math.PI*2);
            ctx.fill();
            ctx.restore();
        }
    }

    class Rocket {
        constructor() {
            this.x = Math.random() * width;
            this.y = height;
            this.vy = -(Math.random() * 5 + 12); // 上升速度
            this.vx = (Math.random() - 0.5) * 2;
            this.color = `hsl(${Math.random()*360}, 100%, 60%)`;
            this.dead = false;
        }
        update() {
            this.x += this.vx; this.y += this.vy;
            this.vy += gravity;
            if (this.vy >= -1) { // 也就是到了顶点附近
                this.dead = true;
                this.explode();
            }
        }
        explode() {
            for(let i=0; i<80; i++) particles.push(new Particle(this.x, this.y, this.color));
        }
        draw(ctx) {
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, 2.5, 0, Math.PI*2);
            ctx.fill();
        }
    }

    function loop() {
        // 使用 clearRect 而不是 fillRect(0,0,w,h) 来保持背景透明，透出底层的 3D 地板
        ctx.clearRect(0, 0, width, height);

        if (Math.random() < 0.05) rockets.push(new Rocket());

        rockets = rockets.filter(r => {
            r.update(); r.draw(ctx);
            return !r.dead;
        });

        particles = particles.filter(p => {
            p.update(); p.draw(ctx);
            return p.alpha > 0;
        });

        requestAnimationFrame(loop);
    }
    loop();
})();

/**
 * ============================================================================
 * 模块三：Shape Shifter 粒子文字引擎 (Text Engine)
 * 负责显示 2026 和祝福语
 * ============================================================================
 */
var S = {
    init: function () {
        S.Drawing.init('#canvas-text');
        // 启动序列：马年祝福无限循环
        S.UI.simulate("#countdown 3|2026|新年快乐|马年大吉|龙马精神|万事如意");
        S.Drawing.loop(function () { S.Shape.render(); });
    }
};

S.Drawing = (function () {
    var canvas, context, renderFn;
    return {
        init: function (el) {
            canvas = document.querySelector(el);
            context = canvas.getContext('2d');
            this.adjustCanvas();
            window.addEventListener('resize', () => this.adjustCanvas());
        },
        loop: function (fn) {
            renderFn = fn;
            (function anim() {
                context.clearRect(0, 0, canvas.width, canvas.height);
                renderFn();
                requestAnimationFrame(anim);
            })();
        },
        adjustCanvas: function () {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        },
        getArea: function () { return { w: canvas.width, h: canvas.height }; },
        drawCircle: function (p, c) {
            context.fillStyle = c.render();
            context.beginPath();
            // 粒子大小随 z 轴变化，模拟景深
            context.arc(p.x, p.y, p.z, 0, 2 * Math.PI, true); 
            context.fill();
        }
    };
})();

S.UI = (function () {
    var interval, sequence = [], cmd = '#';
    
    function performAction(value) {
        if (typeof value === 'string') {
            sequence = value.split('|').filter(s => s.trim() !== '');
        } else {
            sequence = value;
        }

        // 无限循环逻辑
        if (sequence.length === 0) {
            // 播完一轮，重置序列
            performAction("2026|新年快乐|马年大吉|龙马精神|万事如意");
            return;
        }

        var current = sequence.shift();
        var action = current.split(' ')[0];
        var val = current.split(' ')[1];
        var delay = 3000;

        if (action === cmd + 'countdown') {
            val = parseInt(val) || 3;
            var i = val;
            var tmr = setInterval(() => {
                if (i === 0) {
                    clearInterval(tmr);
                    performAction(sequence);
                } else {
                    S.Shape.switchShape(S.ShapeBuilder.letter(i), true);
                    i--;
                }
            }, 1000);
        } else {
            S.Shape.switchShape(S.ShapeBuilder.letter(current));
            setTimeout(() => performAction(sequence), delay);
        }
    }

    return { simulate: performAction };
})();

S.Point = function (args) { this.x = args.x; this.y = args.y; this.z = args.z; this.a = args.a; this.h = args.h; };
S.Color = function (r, g, b, a) { this.r = r; this.g = g; this.b = b; this.a = a; };
S.Color.prototype.render = function () { return `rgba(${this.r},${this.g},${this.b},${this.a})`; };

S.Dot = function (x, y) {
    this.p = new S.Point({ x: x, y: y, z: 5, a: 1, h: 0 });
    this.e = 0.07; this.s = true;
    this.c = new S.Color(255, 255, 255, this.p.a);
    this.t = this.clone(); this.q = [];
};

S.Dot.prototype = {
    clone: function () { return new S.Point({ x: this.x, y: this.y, z: this.z, a: this.a, h: this.h }); },
    _draw: function () { this.c.a = this.p.a; S.Drawing.drawCircle(this.p, this.c); },
    _moveTowards: function (n) {
        var dx = this.p.x - n.x, dy = this.p.y - n.y, d = Math.sqrt(dx*dx + dy*dy), e = this.e * d;
        if (this.p.h === -1) { this.p.x = n.x; this.p.y = n.y; return true; }
        if (d > 1) { this.p.x -= (dx/d)*e; this.p.y -= (dy/d)*e; }
        else { if (this.p.h > 0) this.p.h--; else return true; }
        return false;
    },
    _update: function () {
        if (this._moveTowards(this.t)) {
            var p = this.q.shift();
            if (p) { this.t.x = p.x || this.p.x; this.t.y = p.y || this.p.y; this.t.z = p.z || this.p.z; this.t.a = p.a || this.p.a; this.p.h = p.h || 0; }
            else {
                if (this.s) { this.p.x -= Math.sin(Math.random()*3.14); this.p.y -= Math.sin(Math.random()*3.14); }
                else { this.move(new S.Point({ x: this.p.x + (Math.random()*50)-25, y: this.p.y + (Math.random()*50)-25 })); }
            }
        }
        this.p.a = Math.max(0.1, this.p.a - (this.p.a - this.t.a) * 0.05);
        this.p.z = Math.max(1, this.p.z - (this.p.z - this.t.z) * 0.05);
    },
    move: function (p) { this.q.push(p); },
    render: function () { this._update(); this._draw(); }
};

S.ShapeBuilder = (function () {
    var gap = 11, shapeCanvas = document.createElement('canvas'), shapeContext = shapeCanvas.getContext('2d');
    function fit() { shapeCanvas.width = Math.floor(window.innerWidth / gap) * gap; shapeCanvas.height = Math.floor(window.innerHeight / gap) * gap; }
    function process() {
        var pixels = shapeContext.getImageData(0, 0, shapeCanvas.width, shapeCanvas.height).data, dots = [];
        for (var p = 0, x = 0, y = 0; p < pixels.length; p += (4 * gap)) {
            if (pixels[p + 3] > 0) dots.push(new S.Point({ x: x, y: y }));
            x += gap; if (x >= shapeCanvas.width) { x = 0; y += gap; p += gap * 4 * shapeCanvas.width; }
        }
        return { dots: dots, w: shapeCanvas.width, h: shapeCanvas.height };
    }
    return {
        init: function() { fit(); window.addEventListener('resize', fit); },
        letter: function (l) {
            // 自动字体大小计算
            var fontSize = 600;
            shapeContext.font = "bold " + fontSize + "px Arial";
            var textWidth = shapeContext.measureText(l).width;
            var targetWidth = shapeCanvas.width * 0.8;
            fontSize = Math.min(fontSize, fontSize * (targetWidth / textWidth));
            
            shapeContext.font = "bold " + fontSize + "px Arial";
            shapeContext.fillStyle = "red"; shapeContext.textBaseline = "middle"; shapeContext.textAlign = "center";
            shapeContext.clearRect(0, 0, shapeCanvas.width, shapeCanvas.height);
            shapeContext.fillText(l, shapeCanvas.width / 2, shapeCanvas.height / 2);
            return process();
        }
    };
})();
S.ShapeBuilder.init();

S.Shape = (function () {
    var dots = [], width = 0, height = 0, cx = 0, cy = 0;
    return {
        switchShape: function (n, fast) {
            width = n.w; height = n.h;
            cx = S.Drawing.getArea().w / 2 - width / 2; cy = S.Drawing.getArea().h / 2 - height / 2;
            if (n.dots.length > dots.length) {
                for (var i = dots.length; i < n.dots.length; i++) dots.push(new S.Dot(width/2, height/2));
            }
            var d = 0;
            while (n.dots.length > 0) {
                var i = Math.floor(Math.random() * n.dots.length);
                dots[d].e = fast ? 0.25 : 0.14;
                dots[d].s = true;
                dots[d].move(new S.Point({ x: n.dots[i].x + cx, y: n.dots[i].y + cy, a: 1, z: 5, h: 0 }));
                n.dots.splice(i, 1); d++;
            }
            for (var i = d; i < dots.length; i++) {
                if (dots[i].s) {
                    dots[i].s = false;
                    dots[i].move(new S.Point({ x: Math.random() * width + cx, y: Math.random() * height + cy, a: 0.1, z: 2, h: 0 }));
                }
            }
        },
        render: function () { for (var d = 0; d < dots.length; d++) dots[d].render(); }
    };
})();

S.init();
</script>
</body>
</html>
