<!doctype html>
<html lang="zh">
<head>
<meta charset="utf-8">
<title>2026 马年大吉 - 盛世烟花</title>
<style>
    /* 基础重置 */
    html, body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background-color: #050505; /* 深夜黑 */
        font-family: "Microsoft YaHei", "Heiti SC", sans-serif;
    }

    /* 画布样式 */
    canvas {
        display: block;
        position: absolute;
        top: 0;
        left: 0;
        z-index: 1;
    }

    /* 遮罩层，用于提升文字清晰度 */
    #overlay {
        position: absolute;
        width: 100%;
        height: 100%;
        background: radial-gradient(circle, transparent 20%, #000 90%);
        z-index: 2;
        pointer-events: none;
    }
</style>
</head>
<body>

<div id="overlay"></div>
<canvas id="mainCanvas"></canvas>

<script>
/**
 * ============================================================
 *  2026 马年专属粒子引擎 (Horse Year Particle Engine)
 *  包含：向量数学库、物理系统、文本栅格化系统、烟花系统
 * ============================================================
 */

// --- 配置参数 (Configuration) ---
const CONFIG = {
    particleCount: 1500,        // 文字粒子数量
    fireworkChance: 0.08,       // 烟花发射频率
    gravity: 0.05,              // 环境重力
    friction: 0.96,             // 粒子摩擦力
    textColors: ['#FFD700', '#FFA500', '#FF4500', '#FFFFFF'], // 金、橙、红、白
    bgAlpha: 0.2,               // 拖尾效果强度 (越小拖尾越长)
    font: 'bold 200px "Microsoft YaHei", sans-serif'
};

// --- 数学工具库 (Vector Math Library) ---
class Vector2 {
    constructor(x, y) {
        this.x = x || 0;
        this.y = y || 0;
    }
    add(v) { this.x += v.x; this.y += v.y; return this; }
    sub(v) { this.x -= v.x; this.y -= v.y; return this; }
    mult(n) { this.x *= n; this.y *= n; return this; }
    div(n) { this.x /= n; this.y /= n; return this; }
    mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
    normalize() {
        let m = this.mag();
        if (m !== 0) this.div(m);
        return this;
    }
    limit(max) {
        if (this.mag() > max) {
            this.normalize();
            this.mult(max);
        }
        return this;
    }
    static random2D() {
        let angle = Math.random() * Math.PI * 2;
        return new Vector2(Math.cos(angle), Math.sin(angle));
    }
    clone() { return new Vector2(this.x, this.y); }
}

// --- 基础粒子类 (Base Particle) ---
class Particle {
    constructor(x, y) {
        this.pos = new Vector2(x, y);
        this.vel = new Vector2(0, 0);
        this.acc = new Vector2(0, 0);
        this.alpha = 1;
        this.color = '#fff';
        this.size = 2;
        this.dead = false;
    }

    applyForce(force) {
        this.acc.add(force);
    }

    update() {
        this.vel.add(this.acc);
        this.pos.add(this.vel);
        this.acc.mult(0); // 重置加速度
    }

    draw(ctx) {
        // 子类实现
    }
}

// --- 烟花粒子 (Firework Particle) ---
class FireworkParticle extends Particle {
    constructor(x, y, hue, isSpark) {
        super(x, y);
        this.hue = hue;
        this.isSpark = isSpark; // 是否是爆炸后的火花
        this.lifespan = 255;
        this.decay = isSpark ? Math.random() * 2 + 1 : 2; 
        
        if (this.isSpark) {
            // 爆炸散开
            this.vel = Vector2.random2D();
            this.vel.mult(Math.random() * 6 + 1);
            this.friction = 0.95;
            this.gravity = new Vector2(0, 0.1);
        } else {
            // 上升火箭
            this.vel = new Vector2(0, -(Math.random() * 6 + 10)); // 随机上升速度
            this.friction = 1;
            this.gravity = new Vector2(0, 0.15);
        }
    }

    update() {
        this.applyForce(this.gravity);
        this.vel.mult(this.friction);
        super.update();

        if (this.isSpark) {
            this.lifespan -= this.decay;
            this.alpha = this.lifespan / 255;
            if (this.lifespan <= 0) this.dead = true;
        } else {
            // 火箭上升到了顶点（速度变慢）或者随机时间到达
            if (this.vel.y >= -1) {
                this.dead = true;
            }
        }
    }

    draw(ctx) {
        ctx.save();
        ctx.globalAlpha = this.alpha;
        ctx.fillStyle = `hsl(${this.hue}, 100%, 60%)`;
        ctx.beginPath();
        ctx.arc(this.pos.x, this.pos.y, this.isSpark ? 1.5 : 2.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
    }
}

// --- 文字粒子 (Text Particle) ---
// 这些粒子会组成文字形状
class TextParticle extends Particle {
    constructor(x, y) {
        super(Math.random() * window.innerWidth, Math.random() * window.innerHeight); // 随机出生
        this.target = new Vector2(x, y); // 目标位置
        this.baseSize = Math.random() * 2 + 2;
        this.size = this.baseSize;
        this.color = CONFIG.textColors[Math.floor(Math.random() * CONFIG.textColors.length)];
        this.maxSpeed = 15;
        this.maxForce = 1;
    }

    // 核心行为：寻找目标点 (Arrive Behavior)
    behaviors() {
        let arrive = this.arrive(this.target);
        this.applyForce(arrive);
    }

    arrive(target) {
        let desired = new Vector2(target.x - this.pos.x, target.y - this.pos.y);
        let d = desired.mag();
        let speed = this.maxSpeed;
        if (d < 100) {
            speed = (d / 100) * this.maxSpeed; // 接近时减速
        }
        desired.normalize();
        desired.mult(speed);
        let steer = new Vector2(desired.x - this.vel.x, desired.y - this.vel.y);
        steer.limit(this.maxForce);
        return steer;
    }

    update() {
        this.behaviors();
        super.update();
        // 简单的闪烁效果
        this.size = this.baseSize + Math.sin(Date.now() * 0.01 + this.pos.x) * 1;
    }

    draw(ctx) {
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.pos.x, this.pos.y, this.size, 0, Math.PI * 2);
        ctx.fill();
    }

    setTarget(x, y) {
        this.target = new Vector2(x, y);
    }
}

// --- 烟花系统控制器 (Firework System) ---
class FireworkSystem {
    constructor() {
        this.fireworks = []; // 火箭
        this.particles = []; // 爆炸碎片
    }

    addFirework() {
        // 在屏幕底部随机位置发射
        let x = Math.random() * window.innerWidth;
        // 避开中间文字区域，尽量在两侧发射
        if (Math.abs(x - window.innerWidth/2) < 200) return; 
        
        let hue = Math.random() * 360;
        this.fireworks.push(new FireworkParticle(x, window.innerHeight, hue, false));
    }

    update() {
        // 更新火箭
        for (let i = this.fireworks.length - 1; i >= 0; i--) {
            let fw = this.fireworks[i];
            fw.update();
            if (fw.dead) {
                // 爆炸！生成碎片
                this.explode(fw.pos.x, fw.pos.y, fw.hue);
                this.fireworks.splice(i, 1);
            }
        }
        // 更新碎片
        for (let i = this.particles.length - 1; i >= 0; i--) {
            let p = this.particles[i];
            p.update();
            if (p.dead) this.particles.splice(i, 1);
        }
    }

    explode(x, y, hue) {
        let count = 80 + Math.floor(Math.random() * 50); // 爆炸粒子数
        for (let i = 0; i < count; i++) {
            this.particles.push(new FireworkParticle(x, y, hue, true));
        }
    }

    draw(ctx) {
        // 叠加模式让爆炸更亮
        ctx.globalCompositeOperation = 'lighter';
        this.fireworks.forEach(fw => fw.draw(ctx));
        this.particles.forEach(p => p.draw(ctx));
        ctx.globalCompositeOperation = 'source-over';
    }
}

// --- 文字管理系统 (Text Manager) ---
class TextManager {
    constructor() {
        this.particles = [];
        this.sequence = [
            { text: "3", type: "countdown" },
            { text: "2", type: "countdown" },
            { text: "1", type: "countdown" },
            { text: "2026", type: "year" },
            { text: "新年快乐", type: "bless" },
            { text: "马年大吉", type: "bless" },
            { text: "龙马精神", type: "bless" },
            { text: "万事如意", type: "final" } // 最后一个状态
        ];
        this.currentIndex = 0;
        this.state = "playing"; // playing, waiting, finished
        this.timer = null;
        this.setupParticles();
    }

    // 初始化粒子池
    setupParticles() {
        for (let i = 0; i < CONFIG.particleCount; i++) {
            this.particles.push(new TextParticle(window.innerWidth / 2, window.innerHeight / 2));
        }
    }

    // 将文字栅格化为点坐标
    getTextPoints(text) {
        // 创建离屏 Canvas
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = window.innerWidth;
        tempCanvas.height = window.innerHeight;

        // 绘制文字
        tempCtx.fillStyle = '#fff';
        tempCtx.font = CONFIG.font;
        tempCtx.textAlign = 'center';
        tempCtx.textBaseline = 'middle';
        
        // 自适应字体大小
        if (text.length > 2) tempCtx.font = 'bold 150px "Microsoft YaHei"';
        if (text.length > 4) tempCtx.font = 'bold 120px "Microsoft YaHei"';
        
        tempCtx.fillText(text, tempCanvas.width / 2, tempCanvas.height / 2);

        // 获取像素数据
        const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
        const data = imageData.data;
        const points = [];
        const gap = 8; // 采样间隔 (越小粒子越密)

        for (let y = 0; y < tempCanvas.height; y += gap) {
            for (let x = 0; x < tempCanvas.width; x += gap) {
                const index = (y * tempCanvas.width + x) * 4;
                if (data[index + 3] > 128) { // 如果透明度大于 128 (有文字)
                    points.push({ x: x, y: y });
                }
            }
        }
        return points;
    }

    // 切换到下一个词
    nextWord() {
        if (this.currentIndex >= this.sequence.length) return;

        const currentItem = this.sequence[this.currentIndex];
        const text = currentItem.text;
        const points = this.getTextPoints(text);

        // 分配粒子到新的目标点
        // 如果粒子不够，复用现有的；如果多了，多余的随机飞走
        for (let i = 0; i < this.particles.length; i++) {
            let p = this.particles[i];
            if (i < points.length) {
                // 只有随机选取点位，才不会显得死板
                let ptr = points[i]; 
                p.setTarget(ptr.x, ptr.y);
                p.alpha = 1;
            } else {
                // 多余的粒子，让它们在文字周围盘旋或者隐藏
                p.setTarget(window.innerWidth/2 + (Math.random()-0.5)*500, window.innerHeight/2 + (Math.random()-0.5)*500);
            }
        }
        
        // 调度下一次切换
        let delay = 1000;
        if (currentItem.type === "countdown") delay = 1200;
        else if (currentItem.type === "year") delay = 3000;
        else delay = 2500;

        if (currentItem.type !== "final") {
            setTimeout(() => {
                this.currentIndex++;
                this.nextWord();
            }, delay);
        } else {
            console.log("Sequence finished, text stays.");
        }
    }

    start() {
        this.nextWord();
    }

    update() {
        this.particles.forEach(p => p.update());
    }

    draw(ctx) {
        this.particles.forEach(p => p.draw(ctx));
    }
}

// --- 主程序 (Main Application) ---
class Application {
    constructor() {
        this.canvas = document.getElementById('mainCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.resize();
        
        this.fireworkSystem = new FireworkSystem();
        this.textManager = new TextManager();
        
        window.addEventListener('resize', () => this.resize());
        
        this.loop = this.loop.bind(this);
        this.textManager.start();
        this.loop();
    }

    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
    }

    loop() {
        // 1. 绘制背景 (带拖尾效果)
        this.ctx.globalCompositeOperation = 'source-over';
        this.ctx.fillStyle = `rgba(5, 5, 5, ${CONFIG.bgAlpha})`;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // 2. 随机生成烟花
        if (Math.random() < CONFIG.fireworkChance) {
            this.fireworkSystem.addFirework();
        }

        // 3. 更新和绘制烟花
        this.fireworkSystem.update();
        this.fireworkSystem.draw(this.ctx);

        // 4. 更新和绘制文字
        this.textManager.update();
        this.textManager.draw(this.ctx);

        requestAnimationFrame(this.loop);
    }
}

// 启动程序
window.onload = () => {
    new Application();
};

</script>
</body>
</html>
