<!doctype html>
<html lang="zh">
<head>
<meta charset="utf-8">
<title>2026 马年大吉 - 3D 盛典版</title>

<style>
/* 页面基础样式 */
html,body{
	margin:0px;
	width:100%;
	height:100%;
	overflow:hidden;
	background:#000; /* 纯黑背景 */
}

/* 底层 Canvas：负责绘制 3D 底座和烟花 */
#bg-canvas {
    position:absolute;
    width:100%;
    height:100%;
    z-index:1;
}

/* 顶层 Canvas：负责绘制粒子文字 */
#text-canvas {
    position:absolute;
    width:100%;
    height:100%;
    z-index:2;
    pointer-events: none; /* 让鼠标穿透文字层 */
}
</style>

</head>
<body>

<!-- 两个 Canvas 分层 -->
<canvas id="bg-canvas"></canvas>
<canvas id="text-canvas"></canvas>

<script>
/**
 * ============================================================================
 * 第一部分：3D 舞台引擎 (复活版)
 * 负责：绘制那个酷炫的网格底座 + 3D 烟花
 * ============================================================================
 */
(function() {
    var canvas = document.getElementById("bg-canvas");
    var ctx = canvas.getContext("2d");
    var cx, cy, scale;
    var playerZ = -25;
    var playerX = 0, playerY = 0, pitch = 0, yaw = 0;
    var seeds = [], sparks = [];
    var frames = 0;
    var seedTimer = 0;

    // 烟花配置
    var gravity = 0.02;
    var seedInterval = 5, seedLife = 100;
    var pi = Math.PI;
    
    // 生成火花图片缓存（用 canvas 绘制代替图片加载，防止跨域或加载失败）
    var sparkCanvas = document.createElement('canvas');
    var sparkCtx = sparkCanvas.getContext('2d');
    sparkCanvas.width = 32; sparkCanvas.height = 32;
    var gradient = sparkCtx.createRadialGradient(16,16,0,16,16,16);
    gradient.addColorStop(0, "white");
    gradient.addColorStop(1, "rgba(255,255,255,0)");
    sparkCtx.fillStyle = gradient;
    sparkCtx.beginPath(); sparkCtx.arc(16,16,16,0,Math.PI*2); sparkCtx.fill();

    function initVars(){
        canvas.width = canvas.clientWidth;
        canvas.height = canvas.clientHeight;
        cx = canvas.width/2;
        cy = canvas.height/2;
        scale = 600;
    }

    // --- 核心：3D 投影算法 (您要的底座效果全靠这个) ---
    function rasterizePoint(x,y,z){
        var p,d;
        x-=playerX; y-=playerY; z-=playerZ;
        p=Math.atan2(x,z); d=Math.sqrt(x*x+z*z);
        x=Math.sin(p-yaw)*d; z=Math.cos(p-yaw)*d;
        p=Math.atan2(y,z); d=Math.sqrt(y*y+z*z);
        y=Math.sin(p-pitch)*d; z=Math.cos(p-pitch)*d;
        
        var rx1=-1000, ry1=1, rx2=1000, ry2=1, rx3=0, ry3=0, rx4=x, ry4=z;
        var uc=(ry4-ry3)*(rx2-rx1)-(rx4-rx3)*(ry2-ry1);
        if(!uc) return {x:0,y:0,d:-1};
        var ua=((rx4-rx3)*(ry1-ry3)-(ry4-ry3)*(rx1-rx3))/uc;
        var ub=((rx2-rx1)*(ry1-ry3)-(ry2-ry1)*(rx1-rx3))/uc;
        
        if(!z) z=0.000000001;
        if(ua>0 && ua<1 && ub>0 && ub<1){
            return {
                x:cx+(rx1+ua*(rx2-rx1))*scale,
                y:cy+y/z*scale,
                d:Math.sqrt(x*x+y*y+z*z)
            };
        } else {
            return { x:cx+(rx1+ua*(rx2-rx1))*scale, y:cy+y/z*scale, d:-1 };
        }
    }

    function spawnSeed(){
        var seed = {};
        seed.x = -50 + Math.random()*100;
        seed.y = 25;
        seed.z = -50 + Math.random()*100;
        seed.vx = 0.1 - Math.random()*0.2;
        seed.vy = -1.5;
        seed.vz = 0.1 - Math.random()*0.2;
        seed.born = frames;
        seeds.push(seed);
    }

    function splode(x,y,z){
        var t = 5 + parseInt(Math.random()*150);
        var sparkV = 1 + Math.random()*2.5;
        // 随机颜色
        var r = parseInt(Math.random()*255);
        var g = parseInt(Math.random()*255);
        var b = parseInt(Math.random()*255);
        
        for(var m=1; m<t; ++m){
            var spark={};
            spark.x=x; spark.y=y; spark.z=z;
            var p1=pi*2*Math.random();
            var p2=pi*Math.random();
            var v=sparkV*(1+Math.random()/6);
            spark.vx=Math.sin(p1)*Math.sin(p2)*v;
            spark.vz=Math.cos(p1)*Math.sin(p2)*v;
            spark.vy=Math.cos(p2)*v;
            spark.radius=25+Math.random()*50;
            spark.alpha=1;
            spark.trail=[];
            spark.color = "rgb("+r+","+g+","+b+")";
            sparks.push(spark);
        }
    }

    function doLogic(){
        if(seedTimer<frames){
            seedTimer=frames+seedInterval*Math.random()*10;
            spawnSeed();
        }
        for(var i=0;i<seeds.length;++i){
            seeds[i].vy+=gravity; seeds[i].x+=seeds[i].vx; seeds[i].y+=seeds[i].vy; seeds[i].z+=seeds[i].vz;
            if(frames-seeds[i].born>seedLife){
                splode(seeds[i].x,seeds[i].y,seeds[i].z);
                seeds.splice(i,1);
            }
        }
        for(var i=0;i<sparks.length;++i){
            if(sparks[i].alpha>0 && sparks[i].radius>5){
                sparks[i].alpha-=0.01; sparks[i].radius/=1.02; sparks[i].vy+=gravity;
                var point={x:sparks[i].x,y:sparks[i].y,z:sparks[i].z};
                if(sparks[i].trail.length){
                    var d=sparks[i].trail[sparks[i].trail.length-1];
                    if(Math.pow(point.x-d.x,2)+Math.pow(point.y-d.y,2)+Math.pow(point.z-d.z,2)>9){
                        sparks[i].trail.push(point);
                    }
                }else{
                    sparks[i].trail.push(point);
                }
                if(sparks[i].trail.length>5) sparks[i].trail.splice(0,1);
                sparks[i].x+=sparks[i].vx; sparks[i].y+=sparks[i].vy; sparks[i].z+=sparks[i].vz;
                sparks[i].vx/=1.075; sparks[i].vy/=1.075; sparks[i].vz/=1.075;
            }else{
                sparks.splice(i,1);
            }
        }
        // 摄像机旋转动画
        var p=Math.atan2(playerX,playerZ);
        var d=Math.sqrt(playerX*playerX+playerZ*playerZ);
        d+=Math.sin(frames/80)/1.25;
        var t=Math.sin(frames/200)/40;
        playerX=Math.sin(p+t)*d;
        playerZ=Math.cos(p+t)*d;
        yaw=pi+p+t;
    }

    function draw(){
        ctx.clearRect(0,0,cx*2,cy*2);

        // --- 绘制底座网格 (这就是您要的那个效果！) ---
        ctx.fillStyle="#ff8";
        for(var i=-100; i<100; i+=3){
            for(var j=-100; j<100; j+=4){
                var x=i; var z=j; var y=25;
                var point=rasterizePoint(x,y,z);
                if(point.d!=-1){
                    var size=250/(1+point.d);
                    var d = Math.sqrt(x * x + z * z);
                    var a = 0.75 - Math.pow(d / 100, 6) * 0.75;
                    if(a>0){
                        ctx.globalAlpha = a;
                        ctx.fillRect(point.x-size/2,point.y-size/2,size,size);
                    }
                }
            }
        }

        // --- 绘制 3D 烟花 ---
        ctx.globalAlpha=1;
        // 种子
        for(var i=0;i<seeds.length;++i){
            var point=rasterizePoint(seeds[i].x,seeds[i].y,seeds[i].z);
            if(point.d!=-1){
                var size=200/(1+point.d);
                ctx.fillRect(point.x-size/2,point.y-size/2,size,size);
            }
        }
        // 爆炸火花
        for(var i=0;i<sparks.length;++i){
            var point=rasterizePoint(sparks[i].x,sparks[i].y,sparks[i].z);
            if(point.d!=-1){
                var size=sparks[i].radius*200/(1+point.d);
                if(sparks[i].alpha<0) sparks[i].alpha=0;
                
                // 绘制拖尾
                if(sparks[i].trail.length){
                    ctx.beginPath();
                    // 这里我们简单用火花的颜色
                    ctx.strokeStyle = sparks[i].color; 
                    var p1 = point;
                    for(var j=sparks[i].trail.length-1;j>=0;--j){
                        var point2=rasterizePoint(sparks[i].trail[j].x,sparks[i].trail[j].y,sparks[i].trail[j].z);
                        if(point2.d!=-1){
                            ctx.globalAlpha=j/sparks[i].trail.length*sparks[i].alpha/2;
                            ctx.moveTo(p1.x,p1.y);
                            ctx.lineTo(point2.x,point2.y);
                            p1 = point2;
                        }
                    }
                    ctx.stroke();
                }
                // 绘制火花本体
                ctx.globalAlpha=sparks[i].alpha;
                ctx.drawImage(sparkCanvas, point.x-size/2, point.y-size/2, size, size);
            }
        }
    }

    function frame(){
        if(frames>100000){ seedTimer=0; frames=0; }
        frames++;
        draw();
        doLogic();
        requestAnimationFrame(frame);
    }

    window.addEventListener("resize", initVars);
    initVars();
    frame();
})();

/**
 * ============================================================================
 * 第二部分：文字粒子引擎 (Shape Shifter 增强版)
 * 负责：绘制那个不会消失、可以无限循环的文字
 * ============================================================================
 */
var S = {
  init: function () {
    S.Drawing.init('#text-canvas');
    // --- 在这里配置文字序列 ---
    // #countdown 3 表示倒计时3秒
    // 后面是文字内容，竖线分隔
    S.UI.simulate('#countdown 3|2026|新年快乐|马年大吉|龙马精神|万事如意');
    S.Drawing.loop(function () { S.Shape.render(); });
  }
};

S.Drawing = (function () {
  var canvas, context, renderFn;
  var requestFrame = window.requestAnimationFrame || function(cb) { window.setTimeout(cb, 1000/60); };

  return {
    init: function (el) {
      canvas = document.querySelector(el);
      context = canvas.getContext('2d');
      this.adjustCanvas();
      window.addEventListener('resize', this.adjustCanvas.bind(this));
    },
    loop: function (fn) {
      renderFn = fn;
      this.clearFrame();
      renderFn();
      requestFrame.call(window, this.loop.bind(this));
    },
    adjustCanvas: function () {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    },
    clearFrame: function () {
      context.clearRect(0, 0, canvas.width, canvas.height);
    },
    getArea: function () { return { w: canvas.width, h: canvas.height }; },
    drawCircle: function (p, c) {
      context.fillStyle = c.render();
      context.beginPath();
      // 粒子大小根据 Z 轴微调
      context.arc(p.x, p.y, p.z, 0, 2 * Math.PI, true);
      context.fill();
    }
  };
})();

S.UI = (function () {
  var interval, sequence = [], cmd = '#';
  
  function timedAction(fn, delay, max, reverse) {
    clearInterval(interval);
    var current = reverse ? max : 1;
    fn(current);
    if (!max || (reverse && current > 0) || (!reverse && current < max)) {
      interval = setInterval(function () {
        current = reverse ? current - 1 : current + 1;
        fn(current);
        if ((reverse && current === 0) || (!reverse && current === max)) {
            clearInterval(interval);
        }
      }, delay);
    }
  }

  function performAction(value) {
    if (typeof value === 'string') {
        sequence = value.split('|').filter(function(v){ return v.trim() !== ''; });
    } else {
        sequence = value;
    }

    // 无限循环逻辑
    if (sequence.length === 0) {
        performAction('#countdown 3|2026|新年快乐|马年大吉|龙马精神|万事如意');
        return;
    }

    var current = sequence.shift();
    var action = current.split(' ')[0] === cmd + 'countdown' ? 'countdown' : 'text';
    var val = current.split(' ')[1];

    if (action === 'countdown') {
        var count = parseInt(val) || 3;
        timedAction(function(index) {
            if (index === 0) {
                performAction(sequence);
            } else {
                S.Shape.switchShape(S.ShapeBuilder.letter(index), true);
            }
        }, 1000, count, true);
    } else {
        S.Shape.switchShape(S.ShapeBuilder.letter(current));
        setTimeout(function() {
            performAction(sequence);
        }, 2500); // 文字停留 2.5 秒
    }
  }

  return { simulate: performAction };
})();

S.ShapeBuilder = (function () {
  var gap = 12, shapeCanvas = document.createElement('canvas'), shapeContext = shapeCanvas.getContext('2d');
  function fit() {
    shapeCanvas.width = Math.floor(window.innerWidth / gap) * gap;
    shapeCanvas.height = Math.floor(window.innerHeight / gap) * gap;
    shapeContext.fillStyle = 'red';
    shapeContext.textBaseline = 'middle'; 
    shapeContext.textAlign = 'center';
  }
  fit(); window.addEventListener('resize', fit);

  return {
    letter: function (l) {
      var fontSize = 800;
      shapeContext.font = 'bold ' + fontSize + 'px "Microsoft YaHei", sans-serif';
      var textWidth = shapeContext.measureText(l).width;
      // 自动缩放字体以适应屏幕
      var ratio = (shapeCanvas.width * 0.8) / textWidth;
      var s = Math.min(fontSize, fontSize * ratio, shapeCanvas.height * 0.6);
      
      shapeContext.font = 'bold ' + s + 'px "Microsoft YaHei", sans-serif';
      shapeContext.clearRect(0, 0, shapeCanvas.width, shapeCanvas.height);
      shapeContext.fillText(l, shapeCanvas.width / 2, shapeCanvas.height / 2);

      var pixels = shapeContext.getImageData(0, 0, shapeCanvas.width, shapeCanvas.height).data;
      var dots = [];
      for (var y = 0; y < shapeCanvas.height; y += gap) {
        for (var x = 0; x < shapeCanvas.width; x += gap) {
          if (pixels[((x + y * shapeCanvas.width) * 4) + 3] > 0) {
            dots.push(new S.Point({ x: x, y: y }));
          }
        }
      }
      return { dots: dots, w: shapeCanvas.width, h: shapeCanvas.height };
    }
  };
}());

S.Point = function (args) { this.x = args.x; this.y = args.y; this.z = 5; this.a = 1; this.h = 0; };
S.Color = function (r, g, b, a) { this.r = r; this.g = g; this.b = b; this.a = a; };
S.Color.prototype.render = function () { return 'rgba(' + this.r + ',' +  + this.g + ',' + this.b + ',' + this.a + ')'; };

S.Dot = function (x, y) {
  this.p = new S.Point({ x: x, y: y });
  this.e = 0.07; this.s = true;
  this.c = new S.Color(255, 255, 255, this.p.a);
  this.t = new S.Point({ x: x, y: y }); this.q = [];
};

S.Dot.prototype = {
  _draw: function () { this.c.a = this.p.a; S.Drawing.drawCircle(this.p, this.c); },
  _moveTowards: function (n) {
    var dx = this.p.x - n.x, dy = this.p.y - n.y, d = Math.sqrt(dx * dx + dy * dy), e = this.e * d;
    if (d > 1) { this.p.x -= (dx/d)*e; this.p.y -= (dy/d)*e; return false; }
    return true;
  },
  _update: function () {
    if (this._moveTowards(this.t)) {
      var p = this.q.shift();
      if (p) { this.t.x = p.x; this.t.y = p.y; this.t.a = p.a; }
      else if (this.s) { 
        this.p.x -= Math.sin(Math.random() * 3.142); 
        this.p.y -= Math.sin(Math.random() * 3.142); 
      }
    }
    this.p.a += (this.t.a - this.p.a) * 0.05;
  },
  move: function (p) { this.q.push(p); },
  render: function () { this._update(); this._draw(); }
};

S.Shape = (function () {
  var dots = [];
  return {
    switchShape: function (n, fast) {
      var a = S.Drawing.getArea();
      var cx = a.w / 2 - n.w / 2;
      var cy = a.h / 2 - n.h / 2;

      if (n.dots.length > dots.length) {
        for (var d = dots.length; d < n.dots.length; d++) dots.push(new S.Dot(a.w/2, a.h/2));
      }
      for (var i = 0; i < dots.length; i++) {
        if (i < n.dots.length) {
          dots[i].s = true; dots[i].e = fast ? 0.25 : 0.14;
          dots[i].move(new S.Point({ x: n.dots[i].x + cx, y: n.dots[i].y + cy, a: 1 }));
        } else {
          dots[i].s = false;
          dots[i].move(new S.Point({ x: Math.random()*a.w, y: Math.random()*a.h, a: 0 }));
        }
      }
    },
    render: function () { for (var d = 0; d < dots.length; d++) dots[d].render(); }
  };
}());

// 启动
S.init();
</script>
</body>
</html>
